/*
 * 
 * Fast Universal Simulation Engine (FUSE)
 *
 * Copyright 2014 Jeff Ridder.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


package com.ridderware.fuse.gui;

import java.lang.reflect.Method;
import java.util.ArrayList;
import javax.swing.JButton;
import javax.swing.JOptionPane;
import javax.swing.JTextField;
import org.apache.logging.log4j.*;

/**
 * ReflectorFrame is the actual Frame displayed when you click on a Reflector
 * or select 'All Data Frames' from the 'Windows' menu. It mainly consists of
 * an ArrayList of type Row, which is a inner class of ReflectorFrame.
 * Each row represents a method specified via the Reflector interface.
 * @author Jason C. HandUber
 */
public class ReflectorFrame extends javax.swing.JInternalFrame
{
    private static final Logger logger = LogManager.getLogger(ReflectorFrame.class);
    
    /* The actual Reflector object which we are concerned with */
    private final Reflector reflector;
    
    /**
     * Each method gets its own Row (inner class), which manages all requests of that
     * method (update, setters, invocation, etc).
     */
    private final ArrayList<Row> rows = new ArrayList<>();
    
    /**
     * Creates a new ReflectorFrame
     * @param methods The Methods
     * @param reflector The parent Reflector
     */
    public ReflectorFrame(ArrayList<Method> methods, Reflector reflector)
    {
        this.reflector = reflector;
        this.setTitle(reflector.getTitle());
        initComponents();
        //setLayout(methods);
        addMethodData(methods, reflector);
    }
    
    /**
     * Creates a row for each method passed in, passing data to the Row required for
     * the GridConstraint layout manager (ie. row index)
     * @param methods an ArrayList of type java.lang.reflect.Method containing all Methods this
     * ReflectorFrame should be concerned with
     * @param guiable The Reflector to which these Methods belong, used to invoke
     * the methods.
     */
    private void addMethodData(ArrayList<Method> methods, Reflector reflector)
    {
        int currentRow = 0;
        for (Method method : methods)
        {
            Row row = new Row(method, currentRow++);
            rows.add(row);
        }
    }
    
    /**
     * Updates all strict getter's JTextArea fields. By strict getters I mean a method
     * which takes no arguments and returns an Object (value displayed =
     * Object.toString())
     */
    public void updateSimpleReceiveFields()
    {
        for (Row row : rows)
        {
            row.update();
        }
    }
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        agentDataScrollPane = new javax.swing.JScrollPane();
        agentDataPanel = new javax.swing.JPanel();

        setClosable(true);
        setDefaultCloseOperation(javax.swing.WindowConstants.HIDE_ON_CLOSE);
        setMaximizable(true);
        setResizable(true);
        setDoubleBuffered(true);

        agentDataScrollPane.setDoubleBuffered(true);

        agentDataPanel.setToolTipText("");
        agentDataPanel.setLayout(new java.awt.GridBagLayout());
        agentDataScrollPane.setViewportView(agentDataPanel);

        getContentPane().add(agentDataScrollPane, java.awt.BorderLayout.CENTER);

        setBounds(0, 0, 300, 400);
    }// </editor-fold>//GEN-END:initComponents
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel agentDataPanel;
    private javax.swing.JScrollPane agentDataScrollPane;
    // End of variables declaration//GEN-END:variables
    
    private class Row
    {
        private Method method;
        
        private ArrayList<JTextField> receive = new ArrayList<JTextField>();
        private ArrayList<JTextField> send = new ArrayList<JTextField>();
        private JButton invokeButton;
        
        private JTextField name;
        private JTextField returnValue;
        
        private int rowNumber;
        
        /**
         *
         * @param method The method this row should handle
         * @param rowNumber The row number, used for Layout Managing.
         */
        public Row(Method method, int rowNumber)
        {
            this.rowNumber = rowNumber;
            this.method = method;
            init();
        }
        
        public void update()
        {
            if (method.getReturnType()!=java.lang.Void.TYPE &&
                    method.getParameterTypes().length == 0 &&
                    receive.get(0).getText().trim().length()!=0)
            {
                logger.debug("Updating getter method data: "+ method.getName()+" on reflector: "+ reflector.getTitle());
                try
                {
                    Object rt = method.invoke(reflector);
                    receive.get(0).setText(rt.toString());
                    receive.get(0).validate();
                    receive.get(0).repaint();
                }
                catch (Exception e)
                {e.printStackTrace();}
                logger.debug("trailing: "+receive.get(0).TRAILING+" margines " +receive.get(0).getMargin().toString());
            }
        }
        
        /**
         *  First add the invoke button, setting the text to the
         *  method name
         *  Then add the return field (if applicable)
         *  Then add the arguments/parameters field(s) (if applicable)
         */
        private void init()
        {
            final java.awt.GridBagConstraints gridBagConstraints = new java.awt.GridBagConstraints();
            gridBagConstraints.gridy = rowNumber;
            
            gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
            
            invokeButton = new JButton(method.getName());
            invokeButton.setToolTipText("Press to invoke: "+reflector.getTitle()+"."+method.getName()+" with specified arguments (if any)");
            // invokeButton.setIcon(new javax.swing.ImageIcon(getClass().getResource("/toolbarButtonGraphics/general/Import16.gif")));
            agentDataPanel.add(invokeButton,gridBagConstraints);
            invokeButton.addActionListener(new java.awt.event.ActionListener()
            {
                public void actionPerformed(java.awt.event.ActionEvent evt)
                {
                    Object[] args = new Object[method.getParameterTypes().length];
                    //for each argument fill up the args[]
                    int c = 0;
                    for (JTextField text : send)
                    {
                        Class retType = method.getParameterTypes()[c];
                        logger.debug("Trying to cast ["+ text.getText()+"] into a ["+retType+"]");
                        if (retType.getName().equals("java.lang.String"))
                        {
                            args[c] = text.getText().trim();
                        }
                        else
                        {
                            args[c] = parseString(text.getText().trim(), retType);
                        }
                        c++;
                    }
                    
                    boolean argsError = false;
                    int d = 0;
                    for (Object o : args)
                    {
                        if (o==null)
                        {
                            argsError = true;
                            JOptionPane.showInternalMessageDialog(agentDataPanel, "Error invoking method. Check your arguments", "Unable to Invoke Method", JOptionPane.WARNING_MESSAGE);
                            break;
                        }
                    }
                    
                    if (!argsError)
                    {
                        try
                        {
                            //for debugging
                            String todo = "";
                            for (Object o : args)
                            {
                                todo += o +"<--"+ o.getClass() +"\t";
                            }
                            //logger.debug("Invoking "+ method.getName() +" on guiable: "+ guiable.getName() +" with args: "+ todo+" with return type: "+method.getReturnType());
                            
                            //get the return value and repaint the text component holding it.
                            if (method.getReturnType()!=java.lang.Void.TYPE)
                            {
                                logger.debug("Invoking and setting return type.");
                                Object rt = method.invoke(reflector, args);
                                receive.get(0).setText(rt.toString());
                                logger.debug("trailing: "+receive.get(0).TRAILING+" margines " +receive.get(0).getMargin().toString());
                                validate();
                                repaint();
                            }
                            else
                            {
                                method.invoke(reflector, args);
                                repaint();
                            }
                        }
                        catch(Exception e)
                        {e.printStackTrace();}
                    }
                    FUSEGUI.getGUI().repaint();
                }
            });
            
            gridBagConstraints.weightx = 1.0;
            if (method.getReturnType()!=java.lang.Void.TYPE)
            {
                JTextField returnType = new JTextField();
                returnType.setToolTipText("Displays this method's return value which is a "+ method.getReturnType().getCanonicalName());
                returnType.setEditable(false);
                returnType.setAutoscrolls(true);
                receive.add(returnType);
                agentDataPanel.add(returnType, gridBagConstraints);
            }
            
            
            //arguments/parameters
            for (int i=0; i < method.getParameterTypes().length; i++)
            {
                JTextField parmTypes = new JTextField();
                parmTypes.setText("   ");
                parmTypes.setToolTipText(method.getParameterTypes()[i].getCanonicalName());
                parmTypes.setAutoscrolls(true);
                
                send.add(parmTypes);
                if (i==method.getParameterTypes().length)
                {
                    gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
                }
                agentDataPanel.add(parmTypes,gridBagConstraints);
            }
        }
    }
    
    /**
     * Takes a class, if it is a primitive (boolean, char, byte, short, int, long,
     * float, double) it will wrap the primitive in its Wrapper class (Boolean,
     * Character, etc.), call the valueOf method on that class, and return
     * the resulting Object (isn't reflection so simple?). Null is returned if
     * a non-primitive or associate wrapper or non-java.lang.String is passed in.
     * @param s
     * @param c The Class who may need be wrapped and whose value
     * @return
     */
    private Object parseString(String s, Class c)
    {
        Object result=null;
        logger.debug("name "+ c.getName()+" simple name: "+ c.getSimpleName()+" canonical name: "+ c.getCanonicalName());
        //Method m = class.getMethod("valueOf"); m.invoke(null, new Object[]) { string});
        
        if (c.equals(boolean.class))
        {
            c = Boolean.class;
        }
        else if (c.equals(char.class))
        {
            c = Character.class;
        }
        else if (c.equals(byte.class))
        {
            c = Byte.class;
        }
        else if (c.equals(short.class))
        {
            c = Short.class;
        }
        else if (c.equals(int.class))
        {
            c = Integer.class;
        }
        else if (c.equals(long.class))
        {
            c = Long.class;
        }
        else if (c.equals(float.class))
        {
            c = Float.class;
        }
        else if (c.equals(double.class))
        {
            c = Double.class;
        }
        else if (!(
                (c.equals(Boolean.class)) || (c.equals(Character.class)) || (c.equals(Byte.class))   ||
                (c.equals(Short.class))   || (c.equals(Integer.class))   || (c.equals(Long.class))   ||
                (c.equals(Long.class))    || (c.equals(Float.class))     || (c.equals(Double.class)) ||
                (c.equals(String.class)) ))
        {
            c = null;
        }
        
        if (c!=null)
        {
            Integer n;
            try
            {
                //the Number.valueOf methods (which actually exists in the
                //subclasses thereof) and String.valueOf method take in a String
                Method m = c.getMethod("valueOf", new Class[]{String.class});
                //The valueOf method returns it's own Class, stuff that in result
                //and we are done.
                result = m.invoke(null, new Object[] {s});
            }
            catch (Exception e)
            {
                logger.warn("Unable to parse arguments");
            }
            //logger.debug("Captured Object: "+ result+" of class: "+ result.getClass());
        }
        return result;
    }
}
